#ifndef __CLASS_QUERY_PROCESSOR_H
#define __CLASS_QUERY_PROCESSOR_H
#include "proxysql.h"
#include "cpp.h"

struct _Query_Processor_rule_t {
	int rule_id;
	bool active;
	char *username;
	char *schemaname;
	int flagIN;
	char *match_pattern;
	bool negate_match_pattern;
	int flagOUT;
	char *replace_pattern;
	int destination_hostgroup;
	int cache_ttl;
	bool apply;
	void *regex_engine;
	int hits;
	struct _Query_Processor_rule_t *parent; // pointer to parent, to speed up parent update
};


struct _Query_Processor_output_t {
	void *ptr;
	unsigned int size;
	int destination_hostgroup;
	int cache_ttl;
	std::string *new_query;
};

typedef struct _Query_Processor_rule_t QP_rule_t;
typedef struct _Query_Processor_output_t QP_out_t;


class Query_Processor {

	protected:
	rwlock_t rwlock;
	public:
	Query_Processor() {};
	virtual ~Query_Processor() {};
	virtual const char *version() {return NULL;};
	virtual void print_version() {};
	virtual void reset_all(bool lock=true) {};
	virtual void wrlock() {};		// explicit write lock, to be used in multi-isert 
	virtual void wrunlock() {};	// explicit write unlock
	virtual bool insert(QP_rule_t *qr, bool lock=true) {return false;};		// insert a new rule. Uses a generic void pointer to a structure that may vary depending from the Query Processor
//	virtual bool insert_locked(QP_rule_t *qr) {return false;};		// call this instead of insert() in case lock was already acquired via wrlock()
	virtual QP_rule_t * new_query_rule(int rule_id, bool active, char *username, char *schemaname, int flagIN, char *match_pattern, bool negate_match_pattern, int flagOUT, char *replace_pattern, int destination_hostgroup, int cache_ttl, bool apply) {return NULL;};	// to use a generic query rule struct, this is generated by this function and returned as generic void pointer
	virtual void delete_query_rule(QP_rule_t *qr) {};	// destructor
	virtual bool remove(int rule_id, bool lock=true) {return false;};
//	virtual bool remove_locked(int rule_id) {return false;};		// call this instead of remove() in case lock was already acquired via wrlock()
	virtual QP_out_t * process_mysql_query(MySQL_Session *sess, void *ptr, unsigned int size, bool delete_original) {return NULL;};
	virtual void delete_QP_out(QP_out_t *o) {};

	virtual void sort(bool lock=true) {};

	virtual void init_thread() {};
	virtual void end_thread() {};
	virtual void commit() {};	// this applies all the changes in memory
	virtual SQLite3_result * get_current_query_rules() {return NULL;};

	virtual SQLite3_result * get_stats_query_rules() {return NULL;};	
	virtual void update_query_processor_stats() {};
};


typedef Query_Processor * create_Query_Processor_t();

#endif /* __CLASS_QUERY_PROCESSOR_H */
