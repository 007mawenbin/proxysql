#!/usr/bin/env python

"""
Usage:
  proxysql-consul put <config-name> [--config-file=<config-file>]
  proxysql-consul update [--config-file=<config-file>]
  proxysql-consul (-h | --help)

Options:
  -h --help
        Show this screen.
  --config-file=<config-file>
        Path to config file [default: /etc/proxysql-consul.cnf].

"""

from docopt import docopt
import base64
import json
import os
import requests
import sys
import uuid

import MySQLdb


CFG_PATH = '/etc/proxysql-consul.cnf'
CFG_UUID_FILE = 'uuid_file'
CFG_UUID = 'uuid'
CFG_CONSUL_IFACE = 'consul_iface'
CFG_CONSUL_PORT = 'consul_port'
CFG_PROXY_IFACE = 'proxysql_admin_iface'
CFG_PROXY_PORT = 'proxysql_admin_port'
CFG_PROXY_USERNAME = 'proxysql_admin_username'
CFG_PROXY_PASSWORD = 'proxysql_admin_password'

# Proxysql config types to Consul key mapping
CONFIG_NAME_TO_KEY = {
        'mysql_servers': 'proxysql/mysql_servers',
        'mysql_query_rules': 'proxysql/mysql_query_rules'
        }

RUNTIME_TABLE_BY_TABLE = {
        'mysql_servers': 'runtime_mysql_servers',
        'mysql_replication_hostgroups': 'runtime_mysql_replication_hostgroups',
        'mysql_query_rules': 'runtime_mysql_query_rules'
        }

TABLE_LIST_BY_CONFIG_NAME = {
        'mysql_servers': ['mysql_servers', 'mysql_replication_hostgroups'],
        'mysql_query_rules': ['mysql_query_rules']
        }

SAVE_QUERY_BY_CONFIG_NAME = {
        'mysql_servers': 'SAVE MYSQL SERVERS TO MEMORY',
        'mysql_query_rules': 'SAVE MYSQL QUERY RULES TO MEMORY'
        }

LOAD_QUERY_BY_CONFIG_NAME = {
        'mysql_servers': 'LOAD MYSQL SERVERS FROM MEMORY',
        'mysql_query_rules': 'LOAD MYSQL QUERY RULES FROM MEMORY'
        }

config = {}


def read_config_from_file():
    global config
    with open(CFG_PATH) as config_file:
        config_data = config_file.read()
    config = json.loads(config_data)

    # TODO(ipruanche) validate config


def read_uuid_from_file():
    """
    Reads the UUID identifying this script instance from a file store. If the
    file does not exist creates it and writes a new UUID.

    Puts the UUID in the config dictionary.
    """
    uuid_file_path = config[CFG_UUID_FILE]

    if not os.path.isfile(uuid_file_path):
        _uuid = str(uuid.uuid4())
        with open(uuid_file_path, 'w') as uuid_file:
            uuid_file.write(_uuid)
    else:
        with open(uuid_file_path, 'r') as uuid_file:
            _uuid = uuid_file.read()
    config[CFG_UUID] = _uuid


def read_proxysql_runtime_config(config_name):
    """
    Reads the content of the tables that represent the named config and returns
    it as a dictionary where keys are table names and values lists of rows.

    Each row is a list of the values in the row.

    Will throw an exception if the config_name is not known.
    """
    admin_connection = MySQLdb.connect(config[CFG_PROXY_IFACE],
            config[CFG_PROXY_USERNAME],
            config[CFG_PROXY_PASSWORD],
            port=config[CFG_PROXY_PORT],
            db='main')

    rows_by_table = {}
    for table_name in TABLE_LIST_BY_CONFIG_NAME[config_name]:
        cursor = admin_connection.cursor()
        cursor.execute('SELECT * FROM %s' % RUNTIME_TABLE_BY_TABLE[table_name])
        rows = cursor.fetchall()
        rows_by_table[table_name] = rows
        cursor.close()

    admin_connection.close()
    return rows_by_table 


def put_config_to_consul(config_name):
    if config_name not in CONFIG_NAME_TO_KEY:
        print 'Unknown config name. Exiting.'
        exit(1)

    # read table contents for given config name
    rows_by_table = read_proxysql_runtime_config(config_name)

    consul_data = {}
    # TODO(iprunache) update JSON structure to support multi table configs
    consul_data['config_name'] = config_name
    consul_data['tables'] = rows_by_table
    consul_data['uuid'] = config[CFG_UUID]
    consul_data_json = json.dumps(consul_data)

    key = CONFIG_NAME_TO_KEY[config_name]
    consul_iface = config[CFG_CONSUL_IFACE]
    consul_port = config[CFG_CONSUL_PORT]

    url = 'http://%s:%s/v1/kv/%s' % (consul_iface, consul_port, key)
    r = requests.put(url, data=consul_data_json)
    r.raise_for_status()
    print 'Configs pushed successfully.'


def build_multivalue_insert(table, rows):
    # add quotes arround all values to make them strings in the sql query
    quoted_values = [['"' + x + '"' for x in row] for row in rows]
    # join each row in a values() group
    row_join = [','.join(x) for x in quoted_values]
    query = 'INSERT INTO %s VALUES(%s)' % (table, '),('.join(row_join))
    return query

def update_proxysql_runtime_config(config_name, rows_by_table):
    admin_connection = MySQLdb.connect(config[CFG_PROXY_IFACE],
            config[CFG_PROXY_USERNAME],
            config[CFG_PROXY_PASSWORD],
            port=config[CFG_PROXY_PORT],
            db='main')

    for table_name in rows_by_table.keys():
        rows = rows_by_table[table_name]
        if not rows:
            continue

        # clear table
        cursor = admin_connection.cursor()
        cursor.execute('DELETE FROM %s' % table_name)
        cursor.close()
        
        # insert values from Consul
        insert_query = build_multivalue_insert(table_name, rows)
        cursor = admin_connection.cursor()
        cursor.execute(insert_query)
        cursor.close()

    # commit changes to runtine
    load_query = LOAD_QUERY_BY_CONFIG_NAME[config_name]
    cursor = admin_connection.cursor()
    cursor.execute(load_query)
    cursor.close()

    admin_connection.close()

def update_config():
    """
    Processes the updated config from Consul and if valid pushes it to
    the local ProxySQL instance runtime.
    """

    updated_config_json = read_consul_data()
    updated_config = json.loads(updated_config_json)

    # TODO(iprunache) update JSON structure to support multi table configs
    config_name = updated_config['config_name']
    rows_by_table = updated_config['tables']
    _uuid = updated_config['uuid']
    
    if _uuid == config[CFG_UUID]:
        print 'Ignoring self update.'
        return
    
    update_proxysql_runtime_config(config_name, rows_by_table)
    print 'Configs updated successfully.'

# TODO(iprunache) rename to read_consul_data and extract data processing to
# separate method.
def read_consul_data():
    """
    Reads all input from stdin that is passed by Consul and extracts the config
    that was modified.

    Consul is configured to watch all proxysql keys and returns all their values
    when one key is modified. To determine the value that was actually modified
    we use the CONSUL_INDEX env var written by Consul. This should match the
    'ModifyIndex' field of the value that triggered the watch.

    Values are returned as a JSON array. The actual value content is stored in
    the 'Value' field, base64 encoded.

    Returns the decoded JSON that was the latest to be updated or None if it
    failed to determine which key was last updated.
    """
    if 'CONSUL_INDEX' not in os.environ:
        print 'Missing consul index on update request'
        exit(1)
    consul_index = int(os.environ['CONSUL_INDEX'])
    consul_data = sys.stdin.read()

    updated_value = None
    values = json.loads(consul_data)
    for value in values:
        if 'ModifyIndex' in value and value['ModifyIndex'] == consul_index:
           updated_value = value
           break
    if not updated_value:
        print 'Failed to determine updated key from Consul.'
        exit(1)

    return base64.b64decode(updated_value['Value'])

if __name__ == '__main__':
    arguments = docopt(__doc__, version='proxysql-consul 1.0')
    read_config_from_file()
    read_uuid_from_file()

    if arguments['put']:
        put_config_to_consul(arguments['<config-name>'])
    elif arguments['update']:
        update_config()

